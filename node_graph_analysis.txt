# Node Graph and Elements Analysis
# Energy-Based Neural System Project

## Overview
This project implements a sophisticated energy-driven neural network system using DGL (Deep Graph Library) for graph operations and PyTorch for tensor computations. The system is designed as a self-organizing neural architecture that learns and adapts through energy-driven node dynamics.

## Core Architecture

### 1. Node Types and Hierarchy

The system defines three primary node types with distinct roles:

#### A. Sensory Nodes (NODE_TYPE_SENSORY = 0)
- **Purpose**: Interface with external sensory input (screen capture)
- **Characteristics**:
  - Fixed grid mapping to screen pixels (64x64 by default)
  - Direct energy injection from sensory data
  - No energy decay or maintenance costs
  - Cannot connect to other sensory nodes
  - Cannot connect directly to workspace nodes
- **Energy Management**: Energy directly set from sensory input values (0-1 normalized)
- **Grid Position**: Mapped to sensory input dimensions

#### B. Dynamic Nodes (NODE_TYPE_DYNAMIC = 1)
- **Purpose**: Core processing and learning elements
- **Characteristics**:
  - Compete for energy resources
  - Can grow, shrink, and self-organize
  - Multiple subtypes with different behaviors
  - Can connect to all other node types
  - Subject to energy decay and maintenance costs
- **Subtypes**:
  - **Transmitter** (SUBTYPE_TRANSMITTER = 0): Boosts outgoing energy transfer
  - **Resonator** (SUBTYPE_RESONATOR = 1): Receives energy efficiently, higher decay
  - **Dampener** (SUBTYPE_DAMPENER = 2): Reduces incoming energy, more stable
- **Additional Subtype Slots**:
  - **Subtype2**: Fertility control (Fertile/Normal/Sterile)
  - **Subtype3**: Connection call frequency (1%/5steps, 2%/10steps, 3%/20steps)
  - **Subtype4**: Connection-based energy gain (+1/conn, +0.1/conn, +0.01/conn)

#### C. Workspace Nodes (NODE_TYPE_WORKSPACE = 2)
- **Purpose**: Internal workspace for "imagination" and flexible thinking
  - 16x16 grid by default
  - Can combine perceptions and plan actions
  - Cannot connect to sensory nodes
  - Cannot connect to other workspace nodes
- **Energy Management**: Similar to sensory nodes but with different generation rates

#### D. Highway Nodes (NODE_TYPE_HIGHWAY = 3)
- **Purpose**: Special high-capacity connection nodes
- **Characteristics**:
  - 1% chance to spawn as highway when creating dynamic nodes
  - No connection limits (max_connections = 1000)
  - Special energy transfer mechanics
  - Can connect in 25x25 radius area

### 2. Connection Types and Rules

#### Connection Types
- **Excitatory** (CONN_TYPE_EXCITATORY = 0): Standard positive-weight connections
- **Inhibitory** (CONN_TYPE_INHIBITORY = 1): Negative-weight connections that reduce target energy
- **Gated** (CONN_TYPE_GATED = 2): Only transmit energy if source above threshold
- **Plastic** (CONN_TYPE_PLASTIC = 3): Weight can change over time (learning)

#### Connection Subtypes
- **Subtype2**: Fertility control for connections
- **Subtype3**: Directionality control
  - **OneWayOut**: Only transmits from parent to child
  - **OneWayIn**: Only transmits from child to parent  
  - **FreeFlow**: Bidirectional transmission
- **Subtype4**: Energy gain mechanics

#### Connection Rules
1. **No Self-Connections**: Nodes cannot connect to themselves
2. **Type Restrictions**:
   - No sensory-to-sensory connections
   - No workspace-to-workspace connections
   - No sensory-to-workspace connections
3. **Dynamic Node Constraints**: Can only connect to one of sensory OR workspace (not both), but always to other dynamic nodes
4. **Directionality**: Enforced based on parent-child relationships and connection subtypes

### 3. Energy Economy System

#### Energy Sources
- **Sensory Input**: Direct energy injection from screen capture data
- **Connection Transfers**: Energy flows between connected nodes
- **Base Generation**: Nodes generate energy based on their type and activity
- **Highway Normalization**: Highway nodes balance energy distribution

#### Energy Consumption
- **Node Maintenance**: Each node consumes energy per update cycle
- **Connection Maintenance**: Each outgoing connection costs energy
- **Node Creation**: Spawning new nodes costs energy
- **Connection Creation**: Creating new connections costs energy

#### Energy Caps and Thresholds
- **Energy Cap**: 244.0 (maximum energy any node can hold)
- **Death Threshold**: 0.0 (nodes die if energy falls below)
- **Spawn Threshold**: 20.0 (nodes can spawn connections when above)
- **Emergency Shutdown**: Triggered if energy distribution becomes too extreme

### 4. Graph Structure and Operations

#### DGL Graph Implementation
- **Graph Type**: Directed graph using DGL (Deep Graph Library)
- **Node Features**:
  - `energy`: Current energy level (tensor)
  - `node_type`: Type identifier (0=sensory, 1=dynamic, 2=workspace, 3=highway)
  - `pos`: 2D position coordinates
  - `dynamic_subtype`: Primary subtype for dynamic nodes
  - `dynamic_subtype2-4`: Additional subtype slots
  - `max_connections`: Maximum allowed outgoing connections
  - `velocity`: 2D velocity vector
  - `parent`: Parent node ID for hierarchy tracking
  - `phase_offset`: Phase offset for oscillatory behavior

#### Edge Features
- `weight`: Connection strength/weight
- `energy_transfer_capacity`: Maximum energy transfer per update
- `conn_type`: Connection type (excitatory, inhibitory, gated, plastic)
- `plastic_lr`: Learning rate for plastic connections
- `gate_threshold`: Threshold for gated connections
- `conn_subtype2-3`: Connection subtype information

#### Graph Operations
- **Node Addition**: Batch addition with proper feature initialization
- **Node Removal**: Queue-based removal to maintain graph integrity
- **Edge Addition**: Batch edge creation with validation
- **Edge Removal**: Culling of invalid or weak connections
- **Energy Updates**: Vectorized energy transfer calculations

### 5. Dynamic Growth and Adaptation

#### Node Lifecycle
1. **Spawn**: Nodes spawn when energy exceeds threshold
2. **Growth**: Nodes can create new connections
3. **Decay**: Nodes lose energy over time
4. **Death**: Nodes die when energy falls below threshold

#### Connection Lifecycle
1. **Formation**: New connections created based on energy and proximity
2. **Maintenance**: Connections consume energy to remain active
3. **Culling**: Weak or invalid connections are removed
4. **Learning**: Plastic connections adapt their weights

#### Batch Processing
- **Connection Worker**: Separate thread for connection operations
- **Batch Sizes**: Configurable batch sizes for performance
- **Queue Management**: Task queues for connection growth and culling
- **Error Handling**: Robust error handling and recovery mechanisms

### 6. Visualization and Monitoring

#### Real-time Metrics
- Total system energy
- Node counts by type
- Connection counts
- Birth/death rates
- Average energy levels

#### Visual Displays
- **Sensory Canvas**: Shows current sensory input
- **Workspace Canvas**: Shows internal workspace state
- **Metrics Panel**: Real-time system statistics
- **Control Panel**: System controls and configuration

### 7. Configuration and Tuning

#### Key Parameters
- **Sensory Resolution**: 64x64 pixels by default
- **Workspace Size**: 16x16 grid
- **Update Intervals**: Configurable timing
- **Energy Parameters**: Caps, thresholds, generation rates
- **Growth Limits**: Maximum births per step
- **Connection Limits**: Maximum connections per node

#### Adaptive Settings
- **Memory Management**: Automatic cleanup and optimization
- **Performance Tuning**: GPU acceleration and batch processing
- **Safety Limits**: Emergency shutdown and resource limits

### 8. System Integration

#### Main Components
- **DGLNeuralSystem**: Core neural network implementation
- **ThreadedScreenCapture**: Real-time screen capture
- **MainWindow**: User interface and visualization
- **ConfigManager**: Configuration management
- **StateManager**: System state tracking

#### Data Flow
1. Screen capture provides sensory input
2. Sensory nodes receive and process input
3. Dynamic nodes process and transfer information
4. Workspace nodes provide internal representation
5. Energy flows drive adaptation and learning
6. System metrics are displayed in real-time

### 9. Key Innovations

#### Energy-Driven Learning
- No traditional backpropagation
- Learning emerges from energy dynamics
- Self-organizing network structure
- Adaptive connection formation

#### Multi-Scale Architecture
- Sensory layer for input processing
- Dynamic layer for computation
- Workspace layer for internal representation
- Highway nodes for long-range communication

#### Emergent Behavior
- Pattern recognition through energy flows
- Adaptive network topology
- Self-regulating growth and pruning
- Emergent learning capabilities

### 10. Technical Implementation Details

#### Performance Optimizations
- **Vectorized Operations**: Batch processing for efficiency
- **GPU Acceleration**: CUDA support for large networks
- **Memory Management**: Automatic cleanup and optimization
- **Threading**: Separate workers for connection operations

#### Error Handling
- **Graceful Degradation**: System continues despite errors
- **Recovery Mechanisms**: Automatic error recovery
- **Validation**: Input validation and bounds checking
- **Logging**: Comprehensive error logging and monitoring

This system represents a novel approach to neural networks that emphasizes emergent learning through energy dynamics rather than traditional gradient-based optimization. The node graph serves as both the computational substrate and the learning mechanism, with energy flows driving both information processing and structural adaptation.