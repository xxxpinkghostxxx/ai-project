# AI Project Codebase Map

---

## 1. project/dgl_main.py

### Global Variables / Config
- SENSORY_WIDTH, SENSORY_HEIGHT, N_DYNAMIC, WORKSPACE_SIZE, PERIODIC_UPDATE_MS, LOG_DIR, LOG_PATH, CONN_GRAPH_PATH

### System Initialization
- system = DGLNeuralSystem(...)
- capture = ThreadedScreenCapture(...)

### Tkinter UI Setup
- window, main_frame, left_frame, canvas, metrics_label, sensory_canvas, right_frame, controls_frame, status_var, status_bar
- State: suspend_state, sensory_enabled

### Functions
- update_workspace_canvas()
- update_sensory_canvas(sensory_input)
- pulse_energy()
- drain_and_suspend()
- resume_system()
- toggle_sensory()
- export_screenshot()
- open_config_panel() (with set_resolution(), save_config(), load_config(), reset_defaults(), apply_changes(), restart_system())
- log_system_metrics()
- export_connection_graph()
- update_metrics_panel()
- print_metrics_to_terminal()
- periodic_update()
- on_resize(event)
- on_closing()

### Main Loop
- window.after(100, periodic_update)
- window.mainloop()

Summary: This is the main entry point and orchestrator for the application. It sets up the neural system, screen capture, and the Tkinter-based UI, and manages the main event loop and periodic updates.

---

## 2. project/dgl_neural_system.py

### Constants
- Node types: NODE_TYPE_SENSORY, NODE_TYPE_DYNAMIC, NODE_TYPE_WORKSPACE
- Subtypes: SUBTYPE_TRANSMITTER, SUBTYPE_RESONATOR, SUBTYPE_DAMPENER, SUBTYPE_NAMES
- Connection types: CONN_TYPE_EXCITATORY, CONN_TYPE_INHIBITORY, CONN_TYPE_GATED, CONN_TYPE_PLASTIC, CONN_TYPE_NAMES
- Other config: NODE_SPAWN_THRESHOLD, NODE_DEATH_THRESHOLD, NODE_ENERGY_SPAWN_COST, etc.

### Class: DGLNeuralSystem
- Attributes: device, sensory_width, sensory_height, n_sensory, n_dynamic, workspace_size, n_workspace, n_total, g, metrics counters, etc.
- Methods:
    - __init__
    - _cache_masks
    - _init_graph
    - update (main update logic: sensory transfer, event-driven transfer, decay, birth, death, connection growth, etc.)
    - _spawn_dynamic_nodes
    - _remove_nodes
    - _get_grid_bins
    - _get_neighbor_bins
    - _add_random_connections
    - _periodic_dynamic_growth
    - get_metrics (returns system metrics as a dict)

Summary: This module defines the core neural system, including the graph structure, node/connection types, and the main update logic for simulating energy transfer, node birth/death, and connection growth.

---

## 3. project/vision.py

### Global Variables
- CAPTURE_BACKEND

### Class: ThreadedScreenCapture
- Attributes: width, height, interval, _frame_lock, _latest_frame, _stop_event, _thread, frame_queue, frame_counter, drop_counter, _error_count, _max_retries, _retry_delay
- Methods:
    - __init__
    - __enter__, __exit__
    - start(), stop()
    - _capture_loop()
    - _update_frame_queue(frame)
    - get_latest()
    - get_next_frame(timeout)
    - is_running (property)
    - error_count (property)

### Functions
- capture_screen(resolution)
- preprocess_image(image)

Summary: Handles threaded screen capture using either Pillow or MSS, with robust error handling and frame queueing for real-time sensory input.

---

## 4. project/sensory.py

### Functions
- capture_screen(resolution=(EYE_LAYER_WIDTH, EYE_LAYER_HEIGHT))
- preprocess_image(image, resolution=(EYE_LAYER_WIDTH, EYE_LAYER_HEIGHT))

Summary: Provides simple screen capture and preprocessing utilities for sensory input, using MSS and OpenCV.

---

## 5. project/utils.py

### Functions
- clamp(value, min_value, max_value)
- lerp(a, b, t)
- random_range(rng)
- profile_section(name)
- profile_report()
- has_cupy()
- get_array_module()
- check_cuda_status()
- setup_logging(...)
- get_logger()
- flatten_nodes(nodes)
- extract_node_attrs(node)

### Global Variables
- _profile_timings
- logger (global logger instance)

Summary: Contains general-purpose utility functions for math, profiling, logging, and array handling, used throughout the project.

---

## 6. project/utils/profile_section.py

### Class: ProfileSection
- Context manager for profiling code sections.

### Function: profile_section(name, log_level)
- Decorator for profiling function execution time.

### Class: Profiler
- Tracks multiple profile sections.

### Global
- profiler (global Profiler instance)

Summary: Provides profiling tools to measure and log the performance of code sections and functions.

---

## 7. project/utils/error_handler.py

### Class: ErrorHandler
- Static methods:
    - show_error(title, message, log=True)
    - safe_operation(func)
    - log_warning(message)
    - log_info(message)
    - log_debug(message)

Summary: Centralizes error handling, logging, and user notification for robust and user-friendly error management.

---

## 8. project/utils/config_manager.py

### Class: ConfigManager
- Attributes: config_file, config
- Methods:
    - __init__
    - validate_config(config)
    - create_backup()
    - save_config()
    - load_config()
    - update_config(section, key, value)
    - get_config(section=None, key=None)

Summary: Manages loading, saving, validating, and updating configuration files for the system.

---

## 9. project/system/state_manager.py

### DataClass: SystemState
- suspended, sensory_enabled, last_pulse_time, last_update_time, total_energy, node_count, connection_count

### Class: StateManager
- Attributes: state, _observers
- Methods:
    - add_observer(observer)
    - remove_observer(observer)
    - _notify_observers()
    - toggle_sensory()
    - toggle_suspend()
    - update_metrics(total_energy, node_count, connection_count)
    - get_state()
    - reset()

Summary: Tracks and manages the system's state, including suspension, sensory input, and metrics, and notifies observers of changes.

---

## 10. project/ui/main_window.py

### Class: MainWindow
- Attributes: config_manager, state_manager, resource_manager, frame_counter, window, main_frame, left_frame, canvas, image_id, metrics_label, sensory_canvas, sensory_image_id, right_frame, controls_frame, status_var, status_bar, etc.
- Methods:
    - __init__
    - _create_control_buttons()
    - _create_interval_slider()
    - _toggle_suspend()
    - _pulse_energy()
    - _toggle_sensory()
    - _open_config_panel()
    - _update_interval_changed(value)
    - _on_resize(event)
    - _on_closing()
    - update_workspace_canvas(workspace_data=None)
    - update_sensory_canvas(sensory_data)
    - update_metrics_panel(metrics)
    - on_state_change(state)
    - start_system(system, capture)
    - periodic_update()
    - startup_loop()
    - run()

Summary: Implements the main application window and UI logic, including controls, visualization, and periodic updates, using Tkinter.

---

## 11. project/ui/resource_manager.py

### Class: UIResourceManager
- Attributes: images, windows, _cleanup_handlers, _max_images, _max_windows
- Methods:
    - register_image(image)
    - register_window(window)
    - register_cleanup(handler)
    - cleanup()
    - create_tk_image(image_data, size=None)
    - __del__()

Summary: Manages UI resources such as images and windows, ensuring proper cleanup and memory management.

---

## 12. project/ui/config_panel.py

### Class: ConfigPanel
- Attributes: parent, config_manager, window
- Methods:
    - show()
    - _create_sensory_tab(notebook)
    - _create_workspace_tab(notebook)
    - _create_system_tab(notebook)
    - _update_config(section, key, value)
    - _restart_system()

Summary: Provides a configuration panel UI for editing system, sensory, and workspace settings interactively.

---

## 13. project/config.py

### Global Variables
- All system-wide configuration constants, e.g.:
    - SENSOR_WIDTH, SENSOR_HEIGHT, INITIAL_PROCESSING_NODES, NODE_ENERGY_SPAWN_COST, NODE_ENERGY_CAP, CONN_MAINTENANCE_COST, WORKSPACE_SIZE, MAX_NODE_BIRTHS_PER_STEP, PERIODIC_UPDATE_MS, USE_GPU, etc.

Summary: Central location for all project configuration constants, controlling system behavior, limits, and defaults.

---

## 14. project/__init__.py

### Global
- __version__ = '0.1.0'

Summary: Project version definition and package docstring.

--- 

---

## 15. Neural System Node Logic, Mathematics, and Behavior

### Node Placement and Surrounding Logic
- Nodes are placed on a 2D grid, with positions chosen to maximize spacing (minimum distance) and avoid overlap.
- The method `_get_unoccupied_grid_positions` ensures new nodes are not placed too close to existing nodes, using Euclidean distance checks.
- The grid auto-expands if there is not enough space for new nodes, ensuring all nodes can be placed with the required minimum distance.

**Summary:**
Node placement logic ensures spatial separation, which affects connection probability and local neighborhood structure, supporting emergent topological organization.

### Energy Transfer and Update Mathematics
- Each update step, node energies are updated based on:
  - **Decay:** Dynamic nodes lose energy proportional to their out-degree (number of outgoing connections) and a global decay constant.
  - **Energy Gain:** Nodes gain energy from incoming connections, with transfer amounts determined by edge weights, energy transfer capacities, and node types.
  - **Special Node Types:**
    - Highway nodes normalize their energy to the average of all highway nodes, and can pull energy from dynamic nodes.
    - Sensory and workspace nodes have their own energy update rules and can only connect to certain node types.
- Vectorized operations are used for efficiency, applying updates to all nodes/edges in parallel.

**Summary:**
Energy transfer is governed by connection weights, node types, and capacity constraints, with special rules for highway nodes and type-specific behaviors. Decay and gain are calculated in a mathematically principled, vectorized way.

### Connection and Neighborhood Rules
- **Connection Types:**
  - Excitatory, inhibitory, gated, and plastic connections, each with different transfer and learning rules.
  - Directionality and gating are enforced by connection subtypes and parent relationships.
- **Neighborhood Growth:**
  - New connections are preferentially formed with nearby nodes, using grid binning and distance calculations.
  - Dynamic nodes can only connect to one of sensory or workspace nodes (not both), but always to other dynamic nodes.
  - Sensory nodes cannot connect to workspace nodes, and vice versa.
- **Minimum Connections:**
  - Nodes are guaranteed to have at least one outgoing connection, with preference for workspace, then dynamic, then sensory nodes.
- **Connection Pruning:**
  - Edges are removed if they violate directionality, type, or other constraints, or if their weight drops below a threshold.

**Summary:**
Connection logic enforces biologically-inspired rules for neighborhood, directionality, and type compatibility, supporting emergent modularity and robustness.

### Node Birth, Death, and Emergent Behavior
- **Birth:**
  - Nodes spawn if their energy exceeds a threshold, with costs and probabilities modulated by node subtypes.
  - Placement ensures new nodes do not crowd existing ones.
- **Death:**
  - Nodes are removed if their energy drops below a threshold, with batch processing for efficiency.
- **Emergent Behavior:**
  - The combination of spatial placement, energy transfer, connection rules, and birth/death thresholds leads to self-organizing, adaptive network structures.
  - Highway nodes, dynamic subtypes, and plastic connections introduce further complexity and adaptability.

**Summary:**
Node birth and death are energy-driven, with spatial and type constraints. The system is designed for emergent, adaptive behavior, with local rules giving rise to global organization and dynamics.

--- 

---

## 16. System Logic Breakdowns and Summaries

### Overall System Flow
- The system is initialized in `dgl_main.py`, which sets up configuration, state management, the neural system, screen capture, and the main UI window.
- The main event loop is managed by Tkinter, with periodic updates scheduled using `window.after`.
- Each update cycle includes:
  - Capturing a new sensory frame (if enabled)
  - Updating the neural system with new sensory data
  - Running the neural system's update logic (energy transfer, node birth/death, connection growth/pruning)
  - Applying any queued connection changes
  - Updating the UI with new metrics and visualizations

**Summary:**
The system operates as a real-time loop, integrating sensory input, neural simulation, and user interface updates in a coordinated fashion.

### Component Interactions
- **ConfigManager:** Loads and manages configuration, accessible by all major components.
- **StateManager:** Tracks system state (e.g., suspended, sensory enabled) and notifies observers (like the UI) of changes.
- **DGLNeuralSystem:** Core simulation engine, manages the graph, node/connection logic, and all update mathematics.
- **ThreadedScreenCapture:** Runs in a background thread to provide up-to-date sensory input.
- **MainWindow:** Orchestrates the UI, user controls, and triggers periodic updates.
- **UIResourceManager:** Handles image and window resources for the UI, ensuring proper cleanup.
- **ConfigPanel:** Provides a user interface for editing configuration live.

**Summary:**
Each component has a clear responsibility and communicates via method calls, shared state, or observer patterns. The UI and simulation are decoupled but synchronized through periodic updates and state notifications.

### Main Control Logic
- **Startup:**
  - System and UI are initialized, resources are registered, and the main loop is started.
- **Periodic Update:**
  - Sensory input is captured and processed.
  - Neural system is updated (energy, connections, node birth/death).
  - UI is refreshed with new data and metrics.
  - Connection growth and pruning are queued and applied as needed.
- **User Actions:**
  - Users can pause/resume the system, pulse energy, toggle sensory input, or open the config panel.
  - Configuration changes are applied live and can trigger system restarts.
- **Shutdown:**
  - Resources are cleaned up, windows are closed, and the system exits gracefully.

**Summary:**
The main control logic is event-driven, with a focus on robustness, real-time updates, and user interactivity. The system is designed for extensibility and modularity, allowing new behaviors or UI features to be added with minimal disruption.

--- 